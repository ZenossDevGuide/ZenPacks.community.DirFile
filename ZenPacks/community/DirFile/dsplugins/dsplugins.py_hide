# Setup logging
import logging
log = logging.getLogger('.'.join(['zen', __name__]))

import os
import subprocess

# PythonCollector Imports
from ZenPacks.zenoss.PythonCollector.datasources.PythonDataSource import PythonDataSourcePlugin

# Twisted Imports
from twisted.internet.defer import inlineCallbacks, returnValue, Deferred

class FileDiskUsedPythonDeviceData(PythonDataSourcePlugin):
    """ DirFile File component data source plugin """

    # List of device attributes you might need to do collection.
    proxy_attributes = (
        'zCommandUsername',
        'zCommandPassword',
        'zCommandPath',
        'zKeyPath',
        )

    @classmethod
    def config_key(cls, datasource, context):
        # context will be a File.  

        return (
            context.id,
            datasource.getCycleTime(context),
            datasource.rrdTemplate().id,
            datasource.id,
            datasource.plugin_classname,
	    'FileDiskUsedPythonDeviceData',
            )

    @classmethod
    def params(cls, datasource, context):
        # context is the object that the template is applied to  - either a device or a component
        # Use params method to get at attributes or methods on the context.
        # params is run by zenhub which DOES have access to the ZODB database.
        params = {}
        params['fileName'] = ''
        if hasattr(context, 'fileName'):
            params['fileName'] = context.fileName
        params['fileDirName'] = ''
        if hasattr(context, 'fileDirName'):
            params['fileDirName'] = context.fileDirName
        params['fileId'] = context.id
        # Need to run zenhub in debug to see log.debug statements here
        log.info(' params is %s ' % (params))
        return params

    @inlineCallbacks
    def collect(self, config):

        ds0 = config.datasources[0]
        # Get path to executable file on Zenoss collector, starting from this file
        #    which is in ZenPack base dir/datasources
        #    Executables are in ZenPack base dir / libexec
        thisabspath = os.path.dirname(os.path.abspath(__file__))
        libexecdir = thisabspath + '/libexec'
        # If ds0.zKeyPath starts with ~ then it doesn't expand properly so convert to full path
        #  expanduser gives $HOME including trailing /
        homedir = os.path.expanduser("~")
        if ds0.zKeyPath.startswith('~'):
            keyPath = ds0.zKeyPath.replace('~', homedir)
        else:
            keyPath = ds0.zKeyPath
        fileName = ds0.params['fileDirName'] + '/' + ds0.params['fileName']    
        # script is dufile.sh taking 4 parameters, zCommandUsername, keyPath, hostname, fileName
        cmd = [ os.path.join(libexecdir, 'dufile.sh'), ds0.zCommandUsername, keyPath, ds0.device, fileName ]
        # Next line should cause an error
        #cmd = [ os.path.join(libexecdir, 'dufile.sh'), ds0.zCommandUsername, keyPath, ds0.device, '/blah' ]
        log.debug(' cmd is %s \n ' % (cmd) )

        try:
            cmd_process = yield(subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE))
            # cmd_process.communicate() returns a tuple of (stdoutdata, stderrordata)
            cmd_stdout, cmd_stderr = cmd_process.communicate()
            log.info(' stdout is %s and stderr is %s ' % (cmd_stdout, cmd_stderr))
            if not cmd_stderr:
                retDict = {ds0.params['fileId'] : int(cmd_stdout.rstrip())}
                log.debug('ds0.params is %s and retDict = %s ' % (ds0.params, retDict))
            else:    
                raise Exception(cmd_stderr)
        except:    
            raise Exception('In except clause %s' % (cmd_stderr))
        returnValue(retDict)

    def onResult(self, result, config):
        """
        Called first for success and error.
 
        You can omit this method if you want the result of the collect method
        to be used without further processing.
        """
        log.debug( 'result is %s ' % (result))

        return result


    def onSuccess(self, result, config):
        """
        Called only on success. After onResult, before onComplete.
 
        You should return a data structure with zero or more events, values
        and maps.
        Note that values is a dictionary and events and maps are lists.

        return {
            'events': [{
                'summary': 'successful collection',
                'eventKey': 'myPlugin_result',
                'severity': 0,
                },{
                'summary': 'first event summary',
                'eventKey': 'myPlugin_result',
                'severity': 2,
                },{
                'summary': 'second event summary',
                'eventKey': 'myPlugin_result',
                'severity': 3,
                }],
 
            'values': {
                None: {  # datapoints for the device (no component)
                    'datapoint1': 123.4,
                    'datapoint2': 5.678,
                    },
                'cpu1': {
                    'user': 12.1,
                    nsystem': 1.21,
                    'io': 23,
                    }
                },
 
            'maps': [
                ObjectMap(...),
                RelationshipMap(..),
                ]
            }
            """

        log.debug( 'In success - result is %s and config is %s ' % (result, config))
        data = self.new_data()
        data['values'] = {}
        for ds in config.datasources:
            log.debug(' Start of config.datasources loop')
            for k, v in result.items():
                log.debug('ds.component is %s' % (ds.component))
                log.debug(' k is %s and v is %s ' % (k,v))
                if ds.component == k:
                    for datapoint_id in (x.id for x in ds.points):
                        log.debug('In datapoint loop  datapoint_id is %s ' %(datapoint_id))
                        if datapoint_id not in ['duBytes',]:
                            continue
                        dpname = '_'.join((ds.datasource, 'duBytes'))
                        log.debug('dpname is %s' % (dpname))
                        log.debug('data[values] is %s' % (data['values']))
                        data['values'][ds.component] = {dpname : v}

        #data['maps'] = []
        log.debug( 'data is %s ' % (data))
        return data

    def onError(self, result, config):
        """
        Called only on error. After onResult, before onComplete.
 
        You can omit this method if you want the error result of the collect
        method to be used without further processing. It recommended to
        implement this method to capture errors.
        """
        log.debug( 'In OnError - result is %s and config is %s ' % (result, config))
        return {
            'events': [{
                'summary': 'Error getting file du data with zenpython: %s' % result,
                'eventKey': 'FileDiskUsedPythonDeviceData',
                'severity': 4,
                }],
            }

    def onComplete(self, result, config):
        """
        Called last for success and error.
 
        You can omit this method if you want the result of either the
        onSuccess or onError method to be used without further processing.
        """
        return result


class DirDiskUsedPythonDeviceData(PythonDataSourcePlugin):
    """ DirFile Dir component data source plugin """

    # List of device attributes you might need to do collection.
    proxy_attributes = (
        'zCommandUsername',
        'zCommandPassword',
        'zCommandPath',
        'zKeyPath',
        )

    @classmethod
    def config_key(cls, datasource, context):
        # context will be a Dir.  

        return (
            context.id,
            datasource.getCycleTime(context),
            datasource.rrdTemplate().id,
            datasource.id,
            datasource.plugin_classname,
	    'DirDiskUsedPythonDeviceData',
            )

    @classmethod
    def params(cls, datasource, context):
        # context is the object that the template is applied to  - either a device or a component
        # Use params method to get at attributes or methods on the context.
        # params is run by zenhub which DOES have access to the ZODB database.
        params = {}
        params['dirName'] = ''
        if hasattr(context, 'dirName'):
            params['dirName'] = context.dirName
            params['dirId'] = context.id
        return params

    @inlineCallbacks
    def collect(self, config):

        ds0 = config.datasources[0]
        # Get path to executable file on Zenoss collector, starting from this file
        #    which is in ZenPack base dir/datasources
        #    Executables are in ZenPack base dir / libexec
        thisabspath = os.path.dirname(os.path.abspath(__file__))
        libexecdir = thisabspath + '/libexec'
        # If ds0.zKeyPath starts with ~ then it doesn't expand properly so convert to full path
        #  expanduser gives $HOME including trailing /
        homedir = os.path.expanduser("~")
        if ds0.zKeyPath.startswith('~'):
            keyPath = ds0.zKeyPath.replace('~', homedir)
        else:
            keyPath = ds0.zKeyPath
        # script is dudir.sh taking 4 parameters, zCommandUsername, keyPath, hostname, dirName
        cmd = [ os.path.join(libexecdir, 'dudir.sh'), ds0.zCommandUsername, keyPath, ds0.device, ds0.params['dirName'] ]
        # Next line should cause an error
        #cmd = [ os.path.join(libexecdir, 'dudir.sh'), ds0.zCommandUsername, keyPath, ds0.device, '/blah' ]
        log.debug(' cmd is %s \n ' % (cmd) )
        #cmd_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        #cmd_out = cmd_process.communicate()
        # Either use dd = Deferred() without the @inlineCallbacks decorator or use 
        #   @inlineCallbacks and yield
        #dd = Deferred()
        # cmd_process.communicate() returns a tuple of (stdoutdata, stderrordata)
        #if cmd_process.returncode == 0:
        #    dd.callback(cmd_out[0])
        #else:
        #    dd.errback(cmd_out[1])
        #return dd

        try:
            cmd_process = yield(subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE))
            # cmd_process.communicate() returns a tuple of (stdoutdata, stderrordata)
            cmd_stdout, cmd_stderr = cmd_process.communicate()
            log.info(' stdout is %s and stderr is %s ' % (cmd_stdout, cmd_stderr))
            if not cmd_stderr:
                retDict = {ds0.params['dirId'] : int(cmd_stdout.rstrip())}
                log.debug('ds0.params is %s and retDict = %s ' % (ds0.params, retDict))
            else:    
                raise Exception(cmd_stderr)
        except:    
            raise Exception('In except clause %s' % (cmd_stderr))
        returnValue(retDict)

    def onResult(self, result, config):
        """
        Called first for success and error.
 
        You can omit this method if you want the result of the collect method
        to be used without further processing.
        """
        log.debug( 'result is %s ' % (result))

        return result


    def onSuccess(self, result, config):
        """
        Called only on success. After onResult, before onComplete.
 
        You should return a data structure with zero or more events, values
        and maps.
        Note that values is a dictionary and events and maps are lists.

        return {
            'events': [{
                'summary': 'successful collection',
                'eventKey': 'myPlugin_result',
                'severity': 0,
                },{
                'summary': 'first event summary',
                'eventKey': 'myPlugin_result',
                'severity': 2,
                },{
                'summary': 'second event summary',
                'eventKey': 'myPlugin_result',
                'severity': 3,
                }],
 
            'values': {
                None: {  # datapoints for the device (no component)
                    'datapoint1': 123.4,
                    'datapoint2': 5.678,
                    },
                'cpu1': {
                    'user': 12.1,
                    nsystem': 1.21,
                    'io': 23,
                    }
                },
 
            'maps': [
                ObjectMap(...),
                RelationshipMap(..),
                ]
            }
            """

        log.debug( 'In success - result is %s and config is %s ' % (result, config))
        data = self.new_data()
        data['values'] = {}
        for ds in config.datasources:
            log.debug(' Start of config.datasources loop')
            for k, v in result.items():
                log.debug('ds.component is %s' % (ds.component))
                log.debug(' k is %s and v is %s ' % (k,v))
                if ds.component == k:
                    #data['values'][ds.component]={}
                    for datapoint_id in (x.id for x in ds.points):
                        log.debug('In datapoint loop  datapoint_id is %s ' %(datapoint_id))
                        if datapoint_id not in ['duBytes',]:
                            continue

                        dpname = '_'.join((ds.datasource, 'duBytes'))
                        log.debug('dpname is %s' % (dpname))
                        log.debug('data[values] is %s' % (data['values']))
                        data['values'][ds.component] = {dpname : v}


        data['events'].append({
                    'device': config.id,
                    'summary': 'Dudir',
                    'severity': 1,
                    'eventClass': '/App',
                    'eventKey': 'DirDiskUsedPythonDeviceData',
                    })

        data['maps'] = []

        log.debug( 'data is %s ' % (data))
        return data

    def onError(self, result, config):
        """
        Called only on error. After onResult, before onComplete.
 
        You can omit this method if you want the error result of the collect
        method to be used without further processing. It recommended to
        implement this method to capture errors.
        """
        log.debug( 'In OnError - result is %s and config is %s ' % (result, config))
        return {
            'events': [{
                'summary': 'Error getting directory du data with zenpython: %s' % result,
                'eventKey': 'DirDiskUsedPythonDeviceData',
                'severity': 4,
                }],
            }

    def onComplete(self, result, config):
        """
        Called last for success and error.
 
        You can omit this method if you want the result of either the
        onSuccess or onError method to be used without further processing.
        """
        return result


class RootDiskFreePythonDeviceData(PythonDataSourcePlugin):
    """ RootDiskFree Device data source plugin """

    # List of device attributes you might need to do collection.
    proxy_attributes = (
        'zCommandUsername',
        'zCommandPassword',
        'zCommandPath',
        'zCommandLoginTimeout',
        'zCommandCommandTimeout',
        'zKeyPath',
        'zCommandPort',
        )

    @classmethod
    def config_key(cls, datasource, context):

        return (
            context.id,
            datasource.getCycleTime(context),
            datasource.rrdTemplate().id,
            datasource.id,
            datasource.plugin_classname,
	    'RootDiskFreePythonDeviceData',
            )

    @inlineCallbacks
    def collect(self, config):

        ds0 = config.datasources[0]
        # Get path to executable file, starting from this file
        #    which is in ZenPack base dir/datasources
        #    Executables are in ZenPack base dir / libexec
        thisabspath = os.path.dirname(os.path.abspath(__file__))
        libexecdir = thisabspath + '/libexec'
        # If ds0.zKeyPath starts with ~ then it doesn't expand properly so convert to full path
        #  expanduser gives $HOME including trailing /
        homedir = os.path.expanduser("~")
        if ds0.zKeyPath.startswith('~'):
            keyPath = ds0.zKeyPath.replace('~', homedir)
        else:
            keyPath = ds0.zKeyPath
        # script is df_root_ssh.shh taking 3 parameters, zCommandUsername, keyPath, hostname
        cmd = [ os.path.join(libexecdir, 'df_root_ssh.sh'), ds0.zCommandUsername, keyPath, ds0.device ]
        log.debug(' cmd is %s \n ' % (cmd) )

        try:
            cmd_process = yield(subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE))
            # cmd_process.communicate() returns a tuple of (stdoutdata, stderrordata)
            cmd_stdout, cmd_stderr = cmd_process.communicate()
            log.info(' stdout is %s and stderr is %s ' % (cmd_stdout, cmd_stderr))
            if not cmd_stderr:
                value = int(cmd_stdout.rstrip())
            else:    
                raise Exception(cmd_stderr)
        except:    
            raise Exception('In except clause %s' % (cmd_stderr))
        returnValue(value)



    def onSuccess(self, result, config):
        """
        Called only on success. After onResult, before onComplete.
        """

        log.debug( 'In success - result is %s and config is %s ' % (result, config))
        data = self.new_data()
        data['values'] = {}
        ds0 = config.datasources[0]
        for ds in config.datasources:
            # We are forcing a single value returned from collect to populate
            # a single known datapoint called dfRootPython
            data['values'][None] = {'dfRootPython' : result}
        #data['events'] 
        data['maps'] = []

        log.debug( 'data is %s ' % (data))
        return data

    def onError(self, result, config):
        """
        Called only on error. After onResult, before onComplete.
 
        You can omit this method if you want the error result of the collect
        method to be used without further processing. It recommended to
        implement this method to capture errors.
        """
        log.debug( 'In OnError - result is %s and config is %s ' % (result, config))
        return {
            'events': [{
                'summary': 'Error getting root df data with zenpython: %s' % result,
                'eventKey': 'RootDiskFreePythonDeviceData',
                'severity': 4,
                }],
            }


